/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   gnl.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: achahrou <achahrou@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/30 11:27:00 by achahrou          #+#    #+#             */
/*   Updated: 2024/06/21 07:00:57 by achahrou         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

char	*gnl(int fd)
{
	static t_list	*list = NULL;
	char			*next_line;

	if (fd < 0 || BUFFER_SIZE < 0 || read(fd, &next_line, 0) < 0)
		return (NULL);
	create_list(&list, fd);
	if (list == NULL)
		return (NULL);
	next_line = get_line(list);
	polish_list(&list);
	return (next_line);
}

void	polish_list(t_list **list)
{
	t_list	*last_node;
	t_list	*clean_node;
	int		i;
	int		j;
	char	*buf;

	buf = malloc(BUFFER_SIZE + 1);
	clean_node = malloc(sizeof(t_list));
	if (clean_node == NULL || buf == NULL)
		return ;
	last_node = find_lst_node(*list);
	i = 0;
	j = 0;
	while (last_node->content[i] && last_node->content[i] != '\n')
		++i;
	while (last_node->content[i] && last_node->content[++i])
		buf[j++] = last_node->content[i];
	buf[j] = '\0';
	clean_node->content = buf;
	clean_node->next = NULL;
	dealloc(list, clean_node, buf);
}

void	create_list(t_list **list, int fd)
{
	char	*buf;
	int		readed;

	while (!found_newline(*list))
	{
		buf = malloc(BUFFER_SIZE + 1);
		if (!buf)
			return ;
		readed = read(fd, buf, BUFFER_SIZE);
		if (!readed)
		{
			free(buf);
			return ;
		}
		buf[readed] = '\0';
		append(list, buf);
	}
}

void	append(t_list **list, char *buf)
{
	t_list	*lst_node;
	t_list	*new_node;

	lst_node = find_lst_node(*list);
	new_node = malloc(sizeof(t_list));
	if (!new_node)
		return ;
	if (*list == NULL)
		*list = new_node;
	else
		lst_node->next = new_node;
	new_node->content = buf;
	new_node->next = NULL;
}

char	*get_line(t_list *list)
{
	char	*next_line;
	int		str_len;

	if (NULL == list)
		return (NULL);
	str_len = len_to_newline(list);
	next_line = malloc(str_len + 1);
	if (!next_line)
		return (NULL);
	copy_str(list, next_line);
	return (next_line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   gnl_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: achahrou <achahrou@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/30 12:57:09 by achahrou          #+#    #+#             */
/*   Updated: 2024/06/21 09:34:02 by achahrou         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

int	found_newline(t_list *list)
{
	int	i;

	if (list == NULL)
		return (0);
	while (list)
	{
		i = 0;
		while (list->content[i] && i < BUFFER_SIZE)
		{
			if (list->content[i] == '\n')
				return (1);
			++i;
		}
		list = list->next;
	}
	return (0);
}

t_list	*find_lst_node(t_list *list)
{
	if (list == NULL)
		return (NULL);
	while (list->next)
		list = list->next;
	return (list);
}

int	len_to_newline(t_list *list)
{
	int	i;
	int	len;

	if (list == NULL)
		return (0);
	len = 0;
	while (list)
	{
		i = 0;
		while (list->content[i])
		{
			if (list->content[i] == '\n')
				return (len);
			++len;
			++i;
		}
		list = list->next;
	}
	return (len);
}

void	copy_str(t_list *list, char *str)
{
	int	i;
	int	j;

	if (list == NULL)
		return ;
	j = 0;
	while (list)
	{
		i = 0;
		while (list->content[i])
		{
			if (list->content[i] == '\n')
			{
				str[j] = '\0';
				return ;
			}
			str[j++] = list->content[i++];
		}
		list = list->next;
	}
	str[j] = '\0';
}

void	dealloc(t_list **list, t_list *clean_node, char *buf)
{
	t_list	*tmp;

	if (NULL == *list)
		return ;
	while (*list)
	{
		tmp = (*list)->next;
		free((*list)->content);
		free(*list);
		*list = tmp;
	}
	*list = NULL;
	if (clean_node->content[0])
		*list = clean_node;
	else
	{
		free(buf);
		free(clean_node);
	}
}
#include "../include/miniRT.h"

int	get_color(t_vec3 color)
{
	int	r;
	int	g;
	int	b;

	if (color.x < 0 || color.x > 255 || color.y < 0 \
			|| color.y > 255 || color.z < 0 || color.z > 255)
		return (-1);
	r = fmin(255, color.x * 255);
	g = fmin(255, color.y * 255);
	b = fmin(255, color.z * 255);
	return (r << 16 | g << 8 | b);	
}

int	three_check(char **tab)
{
	if (is_digitf(tab[0]) && is_digitf(tab[1]) && is_digitf(tab[2]))
		return (1);
	return (0);
}

int	em_free(char *mess, char **tab, char **tab2, char **tab3)
{
	if (tab)
		free_tab(tab);
	if (tab2)
		free_tab(tab2);
	if (tab3)
		free_tab(tab3);
	return error(mess);
}

int	fill_amb(t_amb *amb, char *line)
{
	char **tab;
	char **colors;
	int  color;
	int i = 1;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 1 || tab[0][0] != 'A' || tab[0][1] != '\0')
		return em_free("Ambiant light must start with 'A'", tab, NULL, NULL);
	colors = _split(tab[2], ',');
	if (!three_check(colors))
		return em_free(COLOR, tab, colors, NULL);
	color = get_color((t_vec3){_atof(colors[0]), _atof(colors[1]), _atof(colors[2])});
	if (color == -1)
		return em_free(COLOR, tab, colors, NULL);
	if (!is_digitf(tab[1]) || (_atof(tab[1]) < 0 || _atof(tab[1]) > 1))
		return em_free(INTENSITY, tab, colors, NULL);
	amb->intensity = _atof(tab[1]);
	amb->color = (t_vec3){_atof(colors[0]), _atof(colors[1]), _atof(colors[2])};
	free_tab(colors);
	free_tab(tab);
	return (1);
}

int	fill_cam(t_cam *cam, char *line)
{
	char **tab;
	char **ori;
	char **nor;
	int i = 1;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 1 || tab[0][0] != 'C' || tab[0][1] != '\0')
		return em_free("Camera must start with 'C'", tab, NULL, NULL);
	ori = _split(tab[1], ',');
	if (!three_check(ori))
		return em_free(ORIGIN_ERR, ori, tab, NULL);
	cam->origin = (t_vec3){_atof(ori[0]), _atof(ori[1]), _atof(ori[2])};
	nor = _split(tab[2], ',');
	if (!three_check(nor))
		return em_free(DIR_VECTOR, ori, nor, tab);
	if (_atof(nor[0]) < -1 || _atof(nor[0]) > 1 ||\
		_atof(nor[1]) < -1 || _atof(nor[1]) > 1 ||\
		_atof(nor[2]) < -1 || _atof(nor[2]) > 1)
		return em_free(DIR_VECTOR, ori, nor, tab);
	cam->normal = (t_vec3){_atof(nor[0]), _atof(nor[1]), _atof(nor[2])};
	if (!is_digitf(tab[3]) || (_atof(tab[3]) < 0 || _atof(tab[3]) > 180))
		return em_free(FOV_ERR, ori, nor, tab);
	cam->fov = _atof(tab[3]);
	free_tab(ori);
	free_tab(nor);
	free_tab(tab);
	return (1);
}

int	fill_light(t_light *light, char *line)
{
	char **tab;
	char **ori;
	char **colors;
	int color;
	int i = 1;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 1 || tab[0][0] != 'L' || tab[0][1] != '\0')
		return em_free("Light must start with 'L'", tab, NULL, NULL);
	ori = _split(tab[1], ',');
	if (!three_check(ori))
		return em_free(ORIGIN_ERR, ori, tab, NULL);
	light->origin = (t_vec3){_atof(ori[0]), _atof(ori[1]), _atof(ori[2])};
	if (!is_digitf(tab[2]) || _atof(tab[2]) < 0 || _atof(tab[2]) > 1)
		return em_free(INTENSITY, ori, tab, NULL);
	light->intensity = _atof(tab[2]);
	colors = _split(tab[3], ',');
	if (!three_check(colors))
		return em_free(COLOR, ori, colors, tab);
	color = get_color((t_vec3){_atof(colors[0]), _atof(colors[1]), _atof(colors[2])});
	if (color == -1)
		return em_free(COLOR, ori, colors, tab);
	light->color = (t_vec3){_atof(colors[0]), _atof(colors[1]), _atof(colors[2])};
	free_tab(ori);
	free_tab(colors);
	free_tab(tab);
	return (1);
}
#include "../include/miniRT.h"

char	**add_to_map(char **scene, char *new_line)
{
	int		i;
	int		size;
	char	**new_map;

	i = 0;
	size = 0;
	while (scene && scene[size])
		size++;
	new_map = _malloc(sizeof(char *) * (size + 2));
	while (i < size)
	{
		new_map[i] = scene[i];
		i++;
	}
	new_map[i] = new_line;
	new_map[i + 1] = NULL;
	_memdel(scene);
	return (new_map);
}

char **get_scene(char *filename)
{
	char 	*line;
	char	**scene;
	int		fd;

	scene = NULL;
	fd = open(filename, O_RDONLY);
	if (fd == -1)
		return (NULL);
	line = gnl(fd);
	while (line)
	{
		if (is_space(line))
		{
			_memdel(line);
			line = gnl(fd);
			continue;
		}
		scene = add_to_map(scene, line);
		line = gnl(fd);
	}
	close(fd);
	return (scene);
}#include "../include/miniRT.h"

void print_vec3(t_vec3 vec) {
    printf("(x: %.2f, y: %.2f, z: %.2f)\n", vec.x, vec.y, vec.z);
}

void print_sphere_list(t_sph_l *sph) {
    t_sph_l *tmp = sph;
    int index = 0;
    while (tmp != NULL) {
        printf("  Sphere %d:\n", index);
        printf("    Origin: ");
        print_vec3(tmp->sph.origin);
        printf("    Diameter: %.2f\n", tmp->sph.diameter);
        printf("    Color: ");
        print_vec3(tmp->sph.color);
        tmp = tmp->next;
        index++;
        if (tmp) printf("  -------------------------\n");
    }
}

void print_plane_list(t_pla_l *pla) {
    int index = 0;
    while (pla != NULL) {
        printf("  Plane %d:\n", index);
        printf("    Origin: ");
        print_vec3(pla->pla.origin);
        printf("    Normal: ");
        print_vec3(pla->pla.normal);
        printf("    Color: ");
        print_vec3(pla->pla.color);
        pla = pla->next;
        index++;
        if (pla) printf("  -------------------------\n");
    }
}

void print_cylinder_list(t_cyl_l *cyl) {
    int index = 0;
    while (cyl != NULL) {
        printf("  Cylinder %d:\n", index);
        printf("    Origin: ");
        print_vec3(cyl->cyl.origin);
        printf("    Normal: ");
        print_vec3(cyl->cyl.normal);
        printf("    Diameter: %.2f\n", cyl->cyl.diameter);
        printf("    Height: %.2f\n", cyl->cyl.height);
        printf("    Color: \n");
        print_vec3(cyl->cyl.color);
        cyl = cyl->next;
        index++;
        if (cyl) printf("  -------------------------\n");
    }
}

void print_scene(t_scene *scene) {
    printf("Ambient Light:\n");
    printf("  Intensity: %.2f\n", scene->amb.intensity);
    printf("  Color: ");
    print_vec3(scene->amb.color);
    printf("\n");

    printf("Camera:\n");
    printf("  Origin: ");
    print_vec3(scene->cam.origin);
    printf("  Normal: ");
    print_vec3(scene->cam.normal);
    printf("  FOV: %.2f\n", scene->cam.fov);
    printf("\n");

    printf("Light:\n");
    printf("  Origin: ");
    print_vec3(scene->light.origin);
    printf("  Intensity: %.2f\n", scene->light.intensity);
    printf("  Color: ");
    print_vec3(scene->light.color);
    printf("\n");

    printf("Spheres:\n");
    print_sphere_list(scene->sph);
    printf("\n");

    printf("Planes:\n");
    print_plane_list(scene->pla);
    printf("\n");

    printf("Cylinders:\n");
    print_cylinder_list(scene->cyl);
    printf("\n");
}#include "../include/miniRT.h"

int	is_acl(char **tab, char type)
{
	if (_strlen(tab[0]) == 1 && tab[0][0] == type && tab[0][1] == '\0')
		return (1);
	return (0);
}

int	is_spcypl(char **tab, char type, char type2)
{
	if (_strlen(tab[0]) == 2 &&
		(tab[0][0] == type && tab[0][1] == type2)\
		&& tab[0][2] == '\0')
		return (1);
	return (0);
}

void	free_sphl_list(t_sph_l *sph)
{
	t_sph_l *tmp;

	while (sph)
	{
		tmp = sph;
		sph = sph->next;
		free(tmp);
	}
}

void	free_pl_l(t_pla_l *pla)
{
	t_pla_l *tmp;

	while (pla)
	{
		tmp = pla;
		pla = pla->next;
		free(tmp);
	}
}

void	free_cyl_l(t_cyl_l *cyl)
{
	t_cyl_l *tmp;

	while (cyl)
	{
		tmp = cyl;
		cyl = cyl->next;
		free(tmp);
	}
}

void	free_all_l(t_scene *scene)
{
	free_sphl_list(scene->sph);
	free_pl_l(scene->pla);
	free_cyl_l(scene->cyl);
}

int	not_type(char *line)
{
	if (_strlen(line) == 1 && line[0] == 'A' && line[1] == '\0')
		return (1);
	if (_strlen(line) == 1 && line[0] == 'C' && line[1] == '\0')
		return (1);
	if (_strlen(line) == 1 && line[0] == 'L' && line[1] == '\0')
		return (1);
	if (_strlen(line) == 2 && line[0] == 's' && line[1] == 'p'\
		&& line[2] == '\0')
		return (1);
	if (_strlen(line) == 2 && line[0] == 'p' && line[1] == 'l'\
		&& line[2] == '\0')
		return (1);
	if (_strlen(line) == 2 && line[0] == 'c' && line[1] == 'y'\
		&& line[2] == '\0')
		return (1);
	return (0);
}

int	select_a(t_scene *scene, char **tab)
{
	int	i;
	char	**sc;

	i = -1;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_acl(sc, 'A'))
		{
			if (!fill_amb(&scene->amb, tab[i]))
				return (double_free(sc, NULL));
		}
		free_tab(sc);
	}
	return (1);
}
int	select_l(t_scene *scene, char **tab)
{
	int	i;
	char	**sc;

	i = -1;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_acl(sc, 'L'))
		{
			if(!fill_light(&scene->light, tab[i]))
				return (double_free(sc, NULL));
		}
		free_tab(sc);
	}
	return (1);
}

int	select_c(t_scene *scene, char **tab)
{
	int	i;
	char	**sc;

	i = -1;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_acl(sc, 'C'))
		{
			if(!fill_cam(&scene->cam, tab[i]))
				return (double_free(sc, NULL));
		}
		free_tab(sc);
	}
	return (1);
}

int	select_sp(t_scene *scene, char **tab)
{
	int 	i;
	char	**sc;
	t_sph_l *new_node;
	t_sph_l **current;

	i = -1;
	current = &scene->sph;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_spcypl(sc, 's', 'p'))
		{
			new_node = _malloc(sizeof(t_sph_l));
			if (!fill_sphere(&new_node->sph, tab[i]))
				return (double_free(sc, new_node));
			new_node->next = NULL;
			*current = new_node;
			current = &new_node->next;
		}
		free_tab(sc);
	}
	return (1);
}

int	select_pl(t_scene *scene, char **tab)
{
	int 	i;
	char	**sc;
	t_pla_l *new_node;
	t_pla_l **current;

	i = -1;
	current = &scene->pla;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_spcypl(sc, 'p', 'l'))
		{
			new_node = _malloc(sizeof(t_pla_l));
			if (!fill_planet(&new_node->pla, tab[i]))
				return (double_free(sc, new_node));
			new_node->next = NULL;
			*current = new_node;
			current = &new_node->next;
		}
		free_tab(sc);
	}
	return (1);
}

int	select_cy(t_scene *scene, char **tab)
{
	int 	i;
	char	**sc;
	t_cyl_l *new_node;
	t_cyl_l **current;

	i = -1;
	current = &scene->cyl;
	while (tab[++i])
	{
		sc = _split(tab[i], ' ');
		if (!not_type(sc[0]))
			return (double_free(sc, NULL));
		if (is_spcypl(sc, 'c', 'y'))
		{
			new_node = _malloc(sizeof(t_cyl_l));
			if (!fill_cylindre(&new_node->cyl, tab[i]))
				return (double_free(sc, new_node));
			new_node->next = NULL;
			*current = new_node;
			current = &new_node->next;
		}
		free_tab(sc);
	}
	return (1);
}

int	return_free_l(t_scene *scene, int ret)
{
	free_all_l(scene);
	return (ret);
}

int    selecte(t_scene *scene, char **tab)
{
	if (!select_a(scene, tab))
		return (return_free_l(scene, 0));
	if (!select_c(scene, tab))
		return (return_free_l(scene, 0));
	if (!select_l(scene, tab))
		return (return_free_l(scene, 0));
	if (!select_sp(scene, tab))
		return (return_free_l(scene, 0));
	if (!select_pl(scene, tab))
		return (return_free_l(scene, 0));
	if (!select_cy(scene, tab))
		return (return_free_l(scene, 0));
	return (1);
}
#include "../include/miniRT.h"

int fill_sphere(t_sph *sph, char *line)
{
	char    **tab;
	char    **ori;
	char    **col;
	int     color;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 2 || (tab[0][0] != 's' && tab[0][1] != 'p')\
		|| tab[0][2] != '\0')
	{
		free_tab(tab);
		return error("Sphere must start with 's'");
	}
	ori = _split(tab[1], ',');
	if (!three_check(ori))
	{
		free_tab(ori);
		free_tab(tab);
		return error("ORIGIN_ERR");
	}
	sph->origin = (t_vec3){_atof(ori[0]), _atof(ori[1]), _atof(ori[2])};
	if (!is_digitf(tab[2]) || _atof(tab[2]) < 0)
	{
		free_tab(ori);
		free_tab(tab);
		return error(RADIUS);
	}
	sph->diameter = _atof(tab[2]);
	col = _split(tab[3], ',');
	if (!three_check(col))
	{
		free_tab(ori);
		free_tab(col);
		free_tab(tab);
		return error(COLOR);
	}
	color = get_color((t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])});
	if (color == -1)
	{
		free_tab(ori);
		free_tab(col);
		free_tab(tab);
		return error(COLOR);
	}
	sph->color = (t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])};
	free_tab(ori);
	free_tab(col);
	free_tab(tab);
	return (1);
}

int fill_planet(t_pla *pla, char *line)
{
	char    **tab;
	char    **ori;
	char    **nor;
	char    **col;
	int     color;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 2 || (tab[0][0] != 'p' && tab[0][1] != 'l')\
		|| tab[0][2] != '\0')
	{
		free_tab(tab);
		return error("Plane must start with 'p'");
	}
	ori = _split(tab[1], ',');
	if (!three_check(ori))
	{
		free_tab(ori);
		free_tab(tab);
		return error("ORIGIN_ERR");
	}
	pla->origin = (t_vec3){_atof(ori[0]), _atof(ori[1]), _atof(ori[2])};
	nor = _split(tab[2], ',');
	if (!three_check(nor))
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(DIR_VECTOR);
	}
	if (_atof(nor[0]) < -1 || _atof(nor[0]) > 1 ||\
		_atof(nor[1]) < -1 || _atof(nor[1]) > 1 ||\
		_atof(nor[2]) < -1 || _atof(nor[2]) > 1)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(DIR_VECTOR);
	}
	pla->normal = (t_vec3){_atof(nor[0]), _atof(nor[1]), _atof(nor[2])};
	col = _split(tab[3], ',');
	if (!three_check(col))
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(col);
		free_tab(tab);
		return error(COLOR);
	}
	color = get_color((t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])});
	if (color == -1)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(col);
		return error(COLOR);
	}
	pla->color = (t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])};
	free_tab(ori);
	free_tab(nor);
	free_tab(col);
	free_tab(tab);
	return (1);
}

int fill_cylindre(t_cyl *cyl, char *line)
{
	char    **tab;
	char    **ori;
	char    **nor;
	char    **col;
	int     color;

	tab = _split(line, ' ');
	if (_strlen(tab[0]) != 2 || (tab[0][0] != 'c' && tab[0][1] != 'y')\
		|| tab[0][2] != '\0')
	{
		free_tab(tab);
		return error("Cylinder must start with 'cy'");
	}
	ori = _split(tab[1], ',');
	if (!three_check(ori))
	{
		free_tab(ori);
		free_tab(tab);
		return error("ORIGIN_ERR");
	}
	cyl->origin = (t_vec3){_atof(ori[0]), _atof(ori[1]), _atof(ori[2])};
	nor = _split(tab[2], ',');
	if (!three_check(nor))
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(DIR_VECTOR);
	}
	if (_atof(nor[0]) < -1 || _atof(nor[0]) > 1 ||\
		_atof(nor[1]) < -1 || _atof(nor[1]) > 1 ||\
		_atof(nor[2]) < -1 || _atof(nor[2]) > 1)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(DIR_VECTOR);
	}
	cyl->normal = (t_vec3){_atof(nor[0]), _atof(nor[1]), _atof(nor[2])};
	if (!is_digitf(tab[3]) || _atof(tab[3]) < 0)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(RADIUS);
	}
	cyl->diameter = _atof(tab[3]);
	if (!is_digitf(tab[4]) || _atof(tab[4]) < 0)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(tab);
		return error(RADIUS);
	}
	cyl->height = _atof(tab[4]);
	col = _split(tab[5], ',');
	if (!three_check(col))
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(col);
		free_tab(tab);
		return error(COLOR);
	}
	color = get_color((t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])});
	if (color == -1)
	{
		free_tab(ori);
		free_tab(nor);
		free_tab(col);
		free_tab(tab);
		return error(COLOR);
	}
	cyl->color = (t_vec3){_atof(col[0]), _atof(col[1]), _atof(col[2])};
	free_tab(ori);
	free_tab(nor);
	free_tab(col);
	free_tab(tab);
	return (1);
}
#include "../include/miniRT.h"

t_vec3 vec3_add(t_vec3 a, t_vec3 b)
{
    return (t_vec3){a.x + b.x, a.y + b.y, a.z + b.z};
}

t_vec3 vec3_sub(t_vec3 a, t_vec3 b)
{
    return (t_vec3){a.x - b.x, a.y - b.y, a.z - b.z};
}

t_vec3 vec3_scale(t_vec3 v, float s)
{
    return (t_vec3){v.x * s, v.y * s, v.z * s};
}

float vec3_dot(t_vec3 a, t_vec3 b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

t_vec3 vec3_cross(t_vec3 a, t_vec3 b)
{
    return (t_vec3){
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    };
}

float vec3_length(t_vec3 v)
{
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

t_vec3 vec3_normalize(t_vec3 v)
{
    float mag = vec3_length(v);
    return vec3_scale(v, 1.0 / mag);
}
#include "../include/miniRT.h"

int esc_key(int key, t_mlx *mlx)
{
    if (key == 65307)
    {
        mlx_destroy_window(mlx->mlx, mlx->win);
        exit(0);
    }
    return (0);
}

t_camera    set_camera(t_scene *scene)
{
    t_camera    cam;

    cam.origin = scene->cam.origin;
    cam.aspratio = (double)WIDTH / (double)HEIGHT;
    cam.theeta = scene->cam.fov * M_PI / 180;
    cam.width = tan(cam.theeta / 2);
    cam.height = cam.aspratio * cam.width;
    cam.forward = scene->cam.normal;
    cam.up = vec3_normalize(vec3_cross(cam.forward, (t_vec3){0, 1, 0}));
    cam.right = vec3_normalize(vec3_cross(cam.up, cam.forward));
    return (cam);
}

t_ray   set_ray(t_camera *cam, double x, double y)
{
    t_ray   ray;

    ray.dir = vec3_normalize((t_vec3){
        x * cam->right.x + y * cam->up.x + cam->forward.x,
        x * cam->right.y + y * cam->up.y + cam->forward.y,
        x * cam->right.z + y * cam->up.z + cam->forward.z
    });
    ray.origin = cam->origin;
    return (ray);
}#include "../include/miniRT.h"

int is_inside(t_vec3 ray, t_vec3 normal)
{
    return (vec3_dot(ray, normal) > 0);
}

t_vec3  add_coef(t_vec3 col1, t_vec3 col2, float ratio)
{
    t_vec3  ret;

    ret.x = col1.x * (col2.x / 255) * ratio;
    ret.y = col1.y * (col2.y / 255) * ratio;
    ret.z = col1.z * (col2.z / 255) * ratio;
    return (ret);
}

t_vec3  ray_color(t_scene *scene, t_ray *ray, char **sc)
{
    t_inter inter;
    t_vec3  pixel_clr;
    t_vec3  amb;

    inter = intersect(scene, ray, sc);
    // printf("inter.t: %f\n", inter.t);
    if (inter.t > ESP)
    {
        amb = add_coef(inter.color, scene->amb.color, scene->amb.intensity);
        if (is_inside(ray->dir, inter.normal))
            inter.normal = vec3_scale(inter.normal, -1);
        t_light_params params = {
            .point = inter.hit,
            .normal = inter.normal,
            .view_dir = vec3_scale(ray->dir, -1),
            .light = scene->light,
            .object_color = inter.color,
            .spheres = scene->sph,
            .planes = scene->pla,
            .cylinders = scene->cyl,
        };
        printf("object color: %f %f %f\n", inter.color.x, inter.color.y, inter.color.z);
        pixel_clr = calculate_light(params);
        printf("pixel color: %f %f %f\n", pixel_clr.x, pixel_clr.y, pixel_clr.z);
        return (pixel_clr);
    }
    return((t_vec3){0, 0, 0});
}
#include "../include/miniRT.h"

t_inter intersect(t_scene *scene, t_ray *ray, char **tab)
{
    t_inter hold;
    t_scene *sc;
    int     i;

    sc = scene;
    hold.t = -1;
    i = -1;
    while (tab[++i])
    {
        if (tab[i][0] == 's' && sc->sph)
        {
            printf("sphere\n");
            hold = sphere_normal(hold, sc, ray);
            sc->sph = sc->sph->next;
        }
        // if (tab[i][0] == 'p' && tab[i][1] == 'l')
        // {
        //     hold = inter_plane(ray, sc->pl);
        //     sc->pl = sc->pl->next;
        // }
        // if (tab[i][0] == 't')
        // {
        //     hold = inter_cylinder(ray, sc->cyl);
        //     sc->cyl = sc->cyl->next;
        // }
    }
    return (hold);
}#include "../include/miniRT.h"

double inter_sphere(t_ray *ray, t_sph *sph)
{
    t_sphere    sphere;
    double      radius;

    radius = sph->diameter / 2;
    sphere.oc = vec3_sub(ray->origin, sph->origin);
    sphere.a = vec3_dot(ray->dir, ray->dir);
    sphere.b = 2 * vec3_dot(sphere.oc, ray->dir);
    sphere.c = vec3_dot(sphere.oc, sphere.oc) - radius * radius;
    sphere.t = sphere.b * sphere.b - 4 * sphere.a * sphere.c;
    if (sphere.t < 0)
        return (-1);
    sphere.t1 = (-sphere.b - sqrt(sphere.t)) / (2 * sphere.a);
    sphere.t2 = (-sphere.b + sqrt(sphere.t)) / (2 * sphere.a);
    if (sphere.t1 * sphere.t2 > ESP)
    {
        if (sphere.t1 > ESP)
            return (fmin(sphere.t1, sphere.t2));
        return (-1);
    }
    if (sphere.t1 > ESP)
        return (sphere.t1);
    return (sphere.t2);
}

#include "../include/miniRT.h"

t_vec3 calculate_light(t_light_params params) {
    // Normalize vectors
    params.normal = vec3_normalize(params.normal);
    params.view_dir = vec3_normalize(params.view_dir);

    // Calculate light direction and distance
    t_vec3 light_dir = vec3_sub(params.light.origin, params.point);
    float light_distance = vec3_length(light_dir);
    light_dir = vec3_normalize(light_dir);

    // Ambient lighting
    float ambient_strength = 0.1;
    t_vec3 ambient = vec3_scale(params.object_color, ambient_strength);

    // // Check for shadows
    // t_ray shadow_ray = {params.point, light_dir};
    // if (is_in_shadow(shadow_ray, params.spheres, params.planes, params.cylinders, light_distance)) {
    //     // If in shadow, only return ambient light
    //     return ambient;
    // }

    // Diffuse lighting
    float diff = fmax(vec3_dot(params.normal, light_dir), 0.0);
    t_vec3 diffuse = vec3_scale(vec3_scale(params.object_color, params.light.intensity), diff);

    // Specular lighting
    float specular_strength = 0.5;
    t_vec3 reflect_dir = vec3_sub(vec3_scale(params.normal, 2.0 * vec3_dot(light_dir, params.normal)), light_dir);
    float spec = pow(fmax(vec3_dot(params.view_dir, reflect_dir), 0.0), 32);
    t_vec3 specular = vec3_scale(params.light.color, specular_strength * spec * params.light.intensity);

    // Combine all lighting components
    t_vec3 result = vec3_add(vec3_add(ambient, diffuse), specular);

    // Ensure color values are between 0 and 1
    result.x = fmin(result.x, 1.0);
    result.y = fmin(result.y, 1.0);
    result.z = fmin(result.z, 1.0);

    return result;
}
#include "../include/miniRT.h"

void    my_mlx_pixel_put(t_mlx *mlx, int x, int y, int color)
{
    char    *dst;

    dst = mlx->addr + (y * mlx->line_len + x * (mlx->bpp / 8));
    *(unsigned int *)dst = color;
}

void    ft_draw(t_scene *scene, t_mlx *mlx, t_render *render, char **sc)
{
    render->scale = tan(scene->cam.fov * 0.5 * M_PI / 180.0);
    render->x = -1;
    while (++render->x < WIDTH)
    {
        render->y = -1;
        while (++render->y < HEIGHT)
        {
            render->px = 2 * ((double)render->x + 0.5) / ((double)WIDTH - 1)* render->cam.aspratio * render->scale;
            render->py = 1 - 2 * ((double)render->y + 0.5) / ((double)HEIGHT - 1) * render->scale;
            render->ray = set_ray(&render->cam, render->px, render->py);
            render->color = ray_color(scene, &render->ray, sc);
            // printf("color: %f %f %f\n", render->color.x, render->color.y, render->color.z);
            if (render->color.x == 0 && render->color.y == 0 && render->color.z == 0)
                {
                    render->color = (t_vec3){1.0, 0.0, 0.0}; // Red color
                }
            my_mlx_pixel_put(mlx, render->x, render->y, get_color(render->color));
        }
    }
}

void    initialize_window(t_mlx *mlx)
{
    mlx->mlx = mlx_init();
    mlx->win = mlx_new_window(mlx->mlx, WIDTH, HEIGHT, "miniRT");
    mlx->img = mlx_new_image(mlx->mlx, WIDTH, HEIGHT);
    mlx->addr = mlx_get_data_addr(mlx->img, &mlx->bpp, &mlx->line_len, &mlx->endian);
}

void    ft_render(t_scene *scene, t_mlx *mlx, char **sc)
{
    t_render render;

    render.cam = set_camera(scene);
    initialize_window(mlx);
    ft_draw(scene, mlx, &render, sc);
    mlx_put_image_to_window(mlx->mlx, mlx->win, mlx->img, 0, 0);
    mlx_hook(mlx->win, 2, 1L << 0, esc_key, mlx);
    mlx_loop(mlx->mlx);
}#include "../include/miniRT.h"

t_inter sphere_normal(t_inter hold, t_scene *scene, t_ray *ray)
{
    t_inter inter;

    inter.t = inter_sphere(ray, &scene->sph->sph);
    if ((hold.t > inter.t || hold.t == -1) && inter.t > ESP)
    {
        inter.color = scene->sph->sph.color;
        printf("sphere color: %f %f %f\n", inter.color.x, inter.color.y, inter.color.z);
        inter.hit = vec3_add(ray->origin, vec3_scale(ray->dir, inter.t));
        inter.normal = vec3_normalize(vec3_sub(inter.hit, scene->sph->sph.origin));
        hold = inter;
    }
    return (hold);
}#include "../include/miniRT.h"

int		error_main(const char *msg, char **tab)
{
    write(2, "Error: ", 7);
	write(2, msg, _strlen(msg));
	write(2, "\n", 1);
    if (tab)
        free_tab(tab);
	return (0);
}

int	error(const char *msg)
{
	write(2, "Error: ", 7);
	write(2, msg, _strlen(msg));
	write(2, "\n", 1);
	return (0);
}

int    alc_num(char **tab)
{
    char   **sc;
    int     i;
    int     a_count;
    int     l_count;
    int     c_count;

	a_count = 0;
	l_count = 0;
	c_count = 0;
    i = -1;
    while (tab[++i])
    {
        sc = _split(tab[i], ' ');
        if (_strlen(sc[0]) == 1 && sc[0][0] == 'A' && sc[0][1] == '\0')
            a_count++;
        else if (_strlen(sc[0]) == 1 && sc[0][0] == 'L' && sc[0][1] == '\0')
            l_count++;
        else if (_strlen(sc[0]) == 1 && sc[0][0] == 'C' && sc[0][1] == '\0')
            c_count++;
        free_tab(sc);
    }
    if (a_count <= 1 && l_count <= 1 && c_count <= 1)
        return (1);
    return (0);
}

int _check_extension(char *filename)
{
	int i;

	i = _strlen(filename);
	if (i < 4)
		return (1);
	if (filename[i - 3] == '.' && filename[i - 2] == 'r' && filename[i - 1] == 't')
		return (1);
	return (0);

}#include "../include/miniRT.h"

int	is_digit(char c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}

void	*_malloc(size_t size)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
		return (NULL);
	return (ptr);
}

int	is_digitf(char *s)
{
	int i;
	int dot;

	dot = 0;
	i = 0;
	if (s == NULL || *s == '\0')
		return (0);
	if (s[i] == '-')
		i++;
	if (s[i] == '\0' || s[i] == '.')
		return (0);
	while (s[i])
	{
		if (s[0] == '.' || s[_strlen(s) - 1] == '.')
			return (0);
		if (s[i] == '.')
			dot++;
		if ((!is_digit(s[i]) && s[i] != '.') || dot > 1)
			return (0);
		i++;
	}
	return (1);
}


int	is_space(char *s)
{
	int i;

	i = 0;
	while (s[i] == ' ' || s[i] == '\t')
		i++;
	if (s[i] == '\0')
		return (1);
	return (0);
}

void	*_memdel(void *ptr)
{
	if (ptr)
	{
		free(ptr);
		ptr = NULL;
	}
	return (NULL);
}

int	_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

char	*_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	if (little[i] == '\0')
		return ((char *)big);
	while (i < len && big[i])
	{
		while ((i + j) < len && big[i + j] == little[j] && big[i + j])
			j++;
		if (little[j] == '\0')
			return ((char *)big + i);
		j = 0;
		i++;
	}
	return (NULL);
}

float	_atof(char *str)
{
	float	res;
	float	sign;
	int		i;
	float	factor;

	if (!str)
		return (-1);
	i = 0;
	factor = 1.0f;
	res = 0;
	sign = 1;
	if (str[i] == '-')
	{
		sign = -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		res = res * 10 + str[i] - '0';
		i++;
	}
	if (str[i] == '.')
	{
		i++;
		while (str[i] >= '0' && str[i] <= '9')
		{
			factor /= 10.0f;
			res += (str[i] - '0') * factor;
			i++;
		}
	}
	return (res * sign);
}
#include "../include/miniRT.h"

int	double_free(char **tab, void *ptr)
{
	free_tab(tab);
	_memdel(ptr);
	return (0);
}

void	free_tab(char **tab)
{
	int	i;

	i = 0;
	while (tab[i])
	{
		_memdel(tab[i]);
		i++;
	}
	_memdel(tab);
}

int	count_strings(char const *s, char c)
{
	int	i;
	int	str_count;

	i = 0;
	str_count = 0;
	if (s[i] == c)
		str_count--;
	while (s[i] != '\0')
	{
		if (s[i] == c && s[i + 1] != c && s[i + 1] != '\0')
			str_count++;
		i++;
	}
	str_count++;
	return (str_count);
}

char	*malloc_strings(const char *s, char c)
{
	char	*word;
	int		i;

	i = 0;
	while (s[i] && s[i] != c)
		i++;
	word = (char *)malloc(sizeof(char) * (i + 1));
	if (!word)
		return (NULL);
	i = 0;
	while (s[i] && s[i] != c)
	{
		word[i] = s[i];
		i++;
	}
	word[i] = '\0';
	return (word);
}

char	**_split(char const *s, char c)
{
	int		words;
	char	**tab;
	int		i;

	if (!s)
		return (NULL);
	words = count_strings(s, c);
	tab = (char **)malloc(sizeof(char *) * (words + 1));
	if (!tab)
		return (NULL);
	i = 0;
	while (*s)
	{
		while (*s && *s == c)
			s++;
		if (*s && *s != c)
		{
			tab[i] = malloc_strings(s, c);
			i++;
			while (*s && *s != c)
				s++;
		}
	}
	tab[i] = NULL;
	return (tab);
}
#ifndef MINIRT_H
# define MINIRT_H

#include "../../../minilibx-linux/mlx.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include <fcntl.h>
#include "../gnl/gnl.h"

#ifdef __APPLE__
	#define ESC_KEY 53
	#define W_KEY 13
	#define A_KEY 0
	#define S_KEY 1
	#define D_KEY 2
	#define UP 126
	#define DOWN 125
	#define LEFT 123
	#define RIGHT 124

#elif defined(__linux__)
	#define ESC_KEY 65307
	#define W_KEY 119
	#define A_KEY 97
	#define S_KEY 115
	#define D_KEY 100
	#define UP 65362
	#define DOWN 65364
	#define LEFT 65361
	#define RIGHT 65363

#else
	#error "Unsupported operating system"
#endif // __APPLE__ or __linux__

# define DOTRT_ERR "Error\nThe scene file must have a .rt extension.\n"
# define FDNM_ERR "Error\nOne of the normal map file cannot be access.\n"

# define SPACE_POINT 	"must have a point in space"
# define INTENSITY		"intensity must range from 0 to 1"
# define SMOOTHNESS		"smoothness must range from 0 to 1"
# define COLOR			"rgb color components must range from 0 to 255"
# define SIZE_ERR		"size must be positive"
# define REFLECTION		"reflection arguments must range from 0 to 1"
# define TEXTURE		"texture must be either checkers or a bump map"
# define DIR_VECTOR		"direction vector components must range from -1 to 1"
# define FOV_ERR		"FOV must range from 0 to 180"
# define ST_ERR			"stars option can't be implemented"
# define RADIUS			"radius and height must be positive"
# define ORIGIN_ERR		"origin must have 3 coordinates"
# define M_PI			3.14159265358979323846
# define WIDTH			1200
# define HEIGHT			800
# define ESP			0.000001
typedef struct s_vec3
{
	double		x;
	double		y;
	double		z;
}				t_vec3;

typedef struct s_amb
{
	double		intensity;
	t_vec3			color;
}				t_amb;

typedef struct s_cam
{
	t_vec3		origin;
	t_vec3		normal;
	double		fov;
}				t_cam;

typedef struct s_light
{
	t_vec3		origin;
	double		intensity;
	t_vec3			color;// RGB color not used in mendatory part
}				t_light;

typedef struct s_sph
{
	t_vec3		origin;
	double		diameter;
	t_vec3			color;
}				t_sph;

typedef struct s_pla
{
	t_vec3		origin;
	t_vec3		normal;
	t_vec3			color;
}				t_pla;

typedef struct s_cyl
{
	t_vec3		origin;
	t_vec3		normal;
	double		diameter;
	double		height;
	t_vec3			color;
}				t_cyl;

typedef struct s_sph_l
{
	t_sph		sph;
	struct s_sph_l	*next;
}				t_sph_l;

typedef struct s_pla_l
{
	t_pla		pla;
	struct s_pla_l	*next;
}				t_pla_l;

typedef struct s_cyl_l
{
	t_cyl		cyl;
	struct s_cyl_l	*next;
}				t_cyl_l;

typedef struct s_scene
{
	t_amb		amb;
	t_cam		cam;
	t_light		light;
	t_sph_l		*sph;
	t_pla_l		*pla;
	t_cyl_l		*cyl;
}				t_scene;

typedef	struct s_camera
{
	t_vec3		origin;
	t_vec3		up;
	t_vec3		right;
	t_vec3		forward;
	double		width;
	double		height;
	double		aspratio;
	double		theeta;
}				t_camera;

typedef struct s_mlx
{
	void		*mlx;
	void		*win;
	void		*img;
	char		*addr;
	int			bpp;
	int			line_len;
	int			endian;
	int			width;
	int			height;
}				t_mlx;

typedef struct s_ray
{
	t_vec3		origin;
	t_vec3		dir;
}				t_ray;

typedef struct s_render
{
	t_camera	cam;
	t_ray		ray;
	t_vec3		color;
	double		px;
	double		py;
	int			x;
	int			y;
	double		scale;
}				t_render;

typedef struct sphere
{
	double	a;
	double	b;
	double	c;
	double	t;
	double	t1;
	double	t2;
	t_vec3	oc;
}	t_sphere;

typedef struct	s_inter
{
	double		t;
	t_vec3		normal;
	t_vec3		hit;
	t_vec3			color;
}				t_inter;

typedef struct s_light_params {
    t_vec3 point;
    t_vec3 normal;
    t_vec3 view_dir;
    t_vec3 object_color;
    t_light light;
    t_sph_l *spheres;
    t_pla_l *planes;
    t_cyl_l *cylinders;
} t_light_params;



// Structures Parsing

// Library functions error.c
int		error_main(const char *msg, char **tab);
int		error(const char *msg);
int		_check_extension(char *filename);
int		alc_num(char **tab);

// Library functions libft.c
void	*_malloc(size_t size);
void	*_memdel(void *ptr);
int		_strlen(const char *str);
char	*_strnstr(const char *big, const char *little, size_t len);
float	_atof(char *str);
int		is_space(char *s);
int		is_digit(char c);
int		is_digitf(char *s);

// Library functions split.c
char	**_split(char const *s, char c);
void	free_tab(char **tab);
int		double_free(char **tab, void *ptr);

// GET SCENE FUNCTIONS
char	**add_to_map(char **scene, char *new_line);
char	**get_scene(char *filename);

// A, C, L Parsing and Filling
int		get_color(t_vec3 color); // color to int hihi
int		three_check(char **tab);
int		fill_amb(t_amb *amb, char *line);
int		fill_cam(t_cam *cam, char *line);
int		fill_light(t_light *light, char *line);
int		fill_sphere(t_sph *sph, char *line);
int		fill_planet(t_pla *pla, char *line);
int		fill_cylindre(t_cyl *cyl, char *line);

// VECTOR FUNCTIONS
t_vec3 vec3_add(t_vec3 a, t_vec3 b);
t_vec3 vec3_sub(t_vec3 a, t_vec3 b);
t_vec3 vec3_scale(t_vec3 v, float s);
float vec3_dot(t_vec3 a, t_vec3 b);
t_vec3 vec3_cross(t_vec3 a, t_vec3 b);
float vec3_length(t_vec3 v);
t_vec3 vec3_normalize(t_vec3 v);

// SP, PL, CY, A, C, L Printing
void	print_scene(t_scene *scene);

// SP, PL, CY Parsing and Filling and Select
int		selecte(t_scene *scene, char **tab);
void	free_all_l(t_scene *scene);


// RAYTRACE FUNCTIONS

// RAYTRACE COLOR FUNCTIONS
t_vec3 ray_color(t_scene *scene, t_ray *ray, char **sc);

// RAYTRACE CAMERA FUNCTIONS
int esc_key(int key, t_mlx *mlx);
t_camera set_camera(t_scene *scene);
t_ray set_ray(t_camera *cam, double x, double y);

// RAYTRACE FILE FUNCTIONS
void	ft_render(t_scene *scene, t_mlx *mlx, char **sc);

// RAYTRACE INTER FUNCTIONS
t_inter	intersect(t_scene *scene, t_ray *ray, char **tab);

// RAYTRACE SPHERE FUNCTIONS
double inter_sphere(t_ray *ray, t_sph *sph);

// RAYTRACE SUFRFACE NORMAL FUNCTIONS
t_inter sphere_normal(t_inter hold, t_scene *scene, t_ray *ray);

// RAYTRACE LIGHT FUNCTIONS
t_vec3 calculate_light(t_light_params params);

#endif

#include "srcs/include/miniRT.h"

int main(int ac, char *av[]) {
    t_scene scene = {0};
    t_mlx mlx = {0};
    char **sc;

    if (ac != 2 || !_check_extension(av[1]))
        return error("Usage: ./miniRT [scene_file]");
    sc = get_scene(av[1]);
    if (sc == NULL)
        return error_main("Can't read scene file", sc);
    if (!alc_num(sc))
        return error_main("Scene must contain one A, one C and one L", sc);
    if (!selecte(&scene, sc))
        return error_main("Error in scene file", sc);
    print_scene(&scene);
    ft_render(&scene, &mlx, sc);
    free_all_l(&scene);
    free_tab(sc);
}
FLAGS = -g

SRC = miniRT.c \
	srcs/gnl/gnl.c srcs/gnl/gnl_utils.c \
	srcs/utils/libft.c srcs/utils/split.c \
	srcs/utils/error.c \
	srcs/parsing/print_scene.c \
	srcs/parsing/acl.c srcs/parsing/select.c srcs/parsing/sp_pl_cy.c srcs/parsing/get_scene.c\
	srcs/ray_gen/vector.c \
	srcs/raytrace/camera.c srcs/raytrace/raytrace.c srcs/raytrace/intersection.c \
	srcs/raytrace/inter.c srcs/raytrace/color.c srcs/raytrace/lighting.c srcs/raytrace/surface_normal.c

NAME = miniRT
OBJ = $(SRC:.c=.o)

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S), Linux)
    OS_FLAGS = -Lminilibx-linux -lmlx -lX11 -lXext -lm
else ifeq ($(UNAME_S), Darwin)
    OS_FLAGS = -lmlx -framework OpenGL -framework AppKit
else
    $(error Unsupported operating system)
endif

all: $(NAME)

$(NAME): $(OBJ)
	@cc $(FLAGS) $(OBJ) $(OS_FLAGS) -o $(NAME)

%.o: %.c
	@cc $(FLAGS) -c $< -o $@

clean:
	@rm -rf $(OBJ)
	@rm -rf *.o

fclean: clean
	@rm -rf $(NAME)

re: fclean all

.PHONY: all clean fclean re
.SECONDARY: $(OBJ)
